/*
 * Author: Log4JExploit
 * Note: This comment can be removed (see in LICENSE file)
 */

package org.github.log4jexploit.cryptlib;


import org.github.log4jexploit.cryptlib.exceptions.AlgorithmAlreadyImplementedException;
import org.github.log4jexploit.cryptlib.exceptions.AlgorithmNotFoundException;
import org.github.log4jexploit.cryptlib.exceptions.UnsupportedKeySizeException;

import java.io.InvalidClassException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * A Factory class that can create helper classes<br>
 * for easier use of widely used cryptographic algorithms
 */
public class CryptFactory {

    private static final ArrayList<Class<?>> registeredAlgorithms;

    static {
        // Default implementations
        registeredAlgorithms = new ArrayList<>();
        registeredAlgorithms.add(CryptImplAES.class);
        registeredAlgorithms.add(CryptImplRSA.class);
        registeredAlgorithms.add(CryptImplSHA2.class);
        registeredAlgorithms.add(CryptImplSHA3.class);
    }

    private final Class<?> crypt;
    private final int keySize;

    private CryptFactory(Class<?> crypt, int keySize) {
        this.crypt = crypt;
        this.keySize = keySize;
    }

    /**
     * Creates an instance of the requested algorithm, with the desired key size
     * @return the {@link Crypt} instance
     */
    public Crypt createInstance() {
        Crypt instance;
        try {
            instance = (Crypt) this.crypt.getDeclaredConstructor(int.class).newInstance(this.keySize);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return instance;
    }

    /**
     * Gets the defined key size for this factory
     * @return the key size
     */
    public int getKeySize() {
        return keySize;
    }

    public String getAlgorithm() {
        return crypt.getAnnotation(Algorithm.class).name();
    }

    /**
     * Loads an additional class that handles a specific algorithm
     * @param implementation The class that handles a specific algorithm
     * @throws InvalidClassException if the class is not annotated with the {@link Algorithm} annotation or the algorithm is already
     */
    public static void load(Class<?> implementation) throws InvalidClassException {

        // Check if the Algorithm annotation is present
        if(!implementation.isAnnotationPresent(Algorithm.class)) {
            throw new InvalidClassException("Class is missing the org.github.log4jexploit.cryptlib.Algorithm annotation!");
        }

        // Check if the Crypt class has been properly extended
        if(!implementation.getSuperclass().equals(Crypt.class)) {
            throw new InvalidClassException("Class doesn't extend the org.github.log4jexploit.cryptlib.Crypt class!");
        }

        Algorithm annotatedAlgorithm = implementation.getAnnotation(Algorithm.class);

        try {
            //Check if the algorithm is already implemented
            getImplementation(annotatedAlgorithm.name());
            throw new AlgorithmAlreadyImplementedException("An algorithm with the name '"+annotatedAlgorithm.name()+"' is already registered! The algorithm has not been loaded.");
        } catch (Exception ignored) {
            // It's good if the exception is thrown
            // Algorithm is not yet implemented
        }

        registeredAlgorithms.add(implementation);
    }

    /**
     * Used for finding a specific algorithm under the registered algorithms list.
     * @param algorithm the name of the algorithm
     * @return the corresponding class
     * @throws AlgorithmNotFoundException When no class matches the requested name
     */
    private static Class<?> getImplementation(String algorithm) throws AlgorithmNotFoundException {
        Class<?> clazzFound = null;

        for(Class<?> clazz : registeredAlgorithms) {
            String annotatedAlgorithm = clazz.getAnnotation(Algorithm.class).name();
            if(annotatedAlgorithm.equalsIgnoreCase(algorithm)) {
                clazzFound = clazz;
                break;
            }
        }

        if(clazzFound == null)
            throw new AlgorithmNotFoundException("The algorithm '"+algorithm+"' couldn't be found!");

        return clazzFound;
    }

    /**
     * You can use this method to get a helper class for your algorithm of choice, if it is included in the list of registered algorithms.
     * @return A {@link CryptSymmetricFactoryBuilder}
     */
    public static CryptSymmetricFactoryBuilder construct(String algorithm, int keySize) {
        return new CryptSymmetricFactoryBuilder(algorithm, keySize);
    }

    /**
     * You can use this method to get a helper class for your algorithm of choice, if it is included in the list of registered algorithms.
     * @return A {@link CryptSymmetricFactoryBuilder}
     */
    public static CryptSymmetricFactoryBuilder construct(String algorithm) {
        return new CryptSymmetricFactoryBuilder(algorithm);
    }

    /**
     * Returns a list of the registered algorithms
     * @return the list
     */
    public static List<Algorithm.AlgorithmSpec> getRegisteredAlgorithms() {
        List<Algorithm.AlgorithmSpec> list = new ArrayList<>();
        for(Class<?> clazz : registeredAlgorithms) {
            list.add(new Algorithm.AlgorithmSpec(clazz.getAnnotation(Algorithm.class)));
        }
        return list;
    }

    /**
     * A builder to create a factory
     */
    public static class CryptSymmetricFactoryBuilder {

        private final String algorithm;
        private final int keySize;

        private CryptSymmetricFactoryBuilder(String algorithm, int keySize) {
            this.algorithm = algorithm;
            this.keySize = keySize;
        }

        private CryptSymmetricFactoryBuilder(String algorithm) {
            this.algorithm = algorithm;
            this.keySize = -1;
        }

        /**
         * Generates a factory that is initialized with the given algorithm and key size
         * @return the initialized factory
         */
        public CryptFactory build() {
            try {
                Class<?> clazz = getImplementation(this.algorithm);
                ArrayList<Integer> keySizes = new ArrayList<>(Arrays.stream(clazz.getAnnotation(Algorithm.class).keySizes()).boxed().toList());

                if(this.keySize != -1 && !keySizes.contains(this.keySize)) {
                    throw new UnsupportedKeySizeException("Key size "+this.keySize+" not supported for '"+clazz.getAnnotation(Algorithm.class).name()+"'!");
                }

                return new CryptFactory(clazz, this.keySize == -1 ? keySizes.get(keySizes.size()-1) : keySize);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        /**
         * Creates the factory object and uses it to create a single instance of the desired helper class
         * @return A {@link Crypt} instance of the desired helper class
         */
        public Crypt single() {
            return build().createInstance();
        }
    }
}
