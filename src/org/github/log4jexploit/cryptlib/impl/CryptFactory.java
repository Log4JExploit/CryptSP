package org.github.log4jexploit.cryptlib.impl;


import org.github.log4jexploit.cryptlib.Crypt;
import org.github.log4jexploit.cryptlib.CryptSymmetric;
import org.github.log4jexploit.cryptlib.exceptions.AlgorithmNotFoundException;

import java.io.InvalidClassException;
import java.util.ArrayList;
import java.util.List;

public class CryptFactory {

    private static ArrayList<Class<?>> registeredAlgorithms;

    static {
        registeredAlgorithms = new ArrayList<>();
        registeredAlgorithms.add(CryptAES.class);
    }

    private final Class<?> crypt;
    private final int keySize;

    private CryptFactory(Class<?> crypt, int keySize) {
        this.crypt = crypt;
        this.keySize = keySize;
    }

    public Crypt createInstance() {
        Crypt instance;
        try {
            instance = (Crypt) this.crypt.getDeclaredConstructor(int.class).newInstance(this.keySize);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return instance;
    }

    public int getKeySize() {
        return keySize;
    }

    public String getAlgorithm() {
        return crypt.getAnnotation(Algorithm.class).name();
    }

    /**
     * Loads an additional class that handles a specific algorithm
     * @param implementation The class that handles a specific algorithm
     * @throws InvalidClassException if the class is not annotated with the {@link Algorithm} annotation or the algorithm is already
     */
    public static void load(Class<?> implementation) throws InvalidClassException {
        if(!implementation.isAnnotationPresent(Algorithm.class)) {
            throw new InvalidClassException("Class doesn't have the org.github.log4jexploit.cryptlib.impl.Algorithm annotation!");
        }

        Algorithm annotatedAlgorithm = implementation.getAnnotation(Algorithm.class);

        boolean contained = false;
        try {
            getImplementation(annotatedAlgorithm.name());
            contained = true;
        } catch (Exception ignored) {
            // It's good if the exception is thrown
        }

        if(contained) {
            throw new InvalidClassException("An algorithm with the name '"+annotatedAlgorithm.name()+"' is already registered! The algorithm has not been loaded.");
        }

        registeredAlgorithms.add(implementation);
    }

    private static Class<?> getImplementation(String algorithm) throws AlgorithmNotFoundException {
        Class<?> clazzFound = null;

        for(Class<?> clazz : registeredAlgorithms) {
            String annotatedAlgorithm = clazz.getAnnotation(Algorithm.class).name();
            if(annotatedAlgorithm.equalsIgnoreCase(algorithm)) {
                clazzFound = clazz;
                break;
            }
        }

        if(clazzFound == null)
            throw new AlgorithmNotFoundException("The algorithm '"+algorithm+"' couldn't be found!");

        return clazzFound;
    }

    /**
     * You can use this method to get a helper class for your algorithm of choice, if it is included in the algorithm list.
     * @return A {@link CryptSymmetricFactoryBuilder}
     */
    public static CryptSymmetricFactoryBuilder construct(String algorithm, int keySize) {
        return new CryptSymmetricFactoryBuilder(algorithm, keySize);
    }

    public static List<String> getRegisteredAlgorithms() {
        List<String> list = new ArrayList<>();
        for(Class<?> clazz : registeredAlgorithms) {
            list.add(clazz.getAnnotation(Algorithm.class).name());
        }
        return list;
    }

    public static class CryptSymmetricFactoryBuilder {

        private final String algorithm;
        private final int keySize;

        public CryptSymmetricFactoryBuilder(String algorithm, int keySize) {
            this.algorithm = algorithm;
            this.keySize = keySize;
        }

        public CryptFactory build() {
            try {
                Class<?> clazz = getImplementation(this.algorithm);
                if(clazz)
                return new CryptFactory(clazz, this.keySize);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public Crypt single() {
            return build().createInstance();
        }
    }
}
